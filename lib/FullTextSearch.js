/* globals XPCOMUtils, Task, OS, Sqlite */
"use strict";

const {Cu} = require("chrome");
Cu.import("resource://gre/modules/Services.jsm");
Cu.import("resource://gre/modules/XPCOMUtils.jsm");
Cu.import("resource://gre/modules/Sqlite.jsm");
Cu.import("resource://gre/modules/Timer.jsm");
const bookmarks = require("sdk/places/bookmarks");
const history = require("sdk/places/history");
const tabs = require("sdk/tabs");

XPCOMUtils.defineLazyModuleGetter(this, "Task",
                                  "resource://gre/modules/Task.jsm");
XPCOMUtils.defineLazyModuleGetter(this, "PlacesUtils",
                                  "resource://gre/modules/PlacesUtils.jsm");
XPCOMUtils.defineLazyModuleGetter(this, "OS",
                                  "resource://gre/modules/osfile.jsm");

const FTSSTORE_NAME = "fts.sqlite";

const SQL_DDLS = [
  `CREATE VIRTUAL TABLE IF NOT EXISTS fts_pages USING fts4(
      url LONGVARCHAR,
      title TEXT,
      type VARCHAR(32),
      description TEXT,
      body TEXT,
      last_visit DATETIME,
      tokenize=porter
  )`
];

const SQL_LAST_INSERT_ROWID = "SELECT last_insert_rowid() AS lastInsertRowID";

/**
 * A place holder for the database migrations in the future
 */
const SQL_MIGRATIONS = [];

const SQL_INSERT_FTS_PAGES = `INSERT INTO fts_pages
  (url, title, type, description, body, last_visit)
  VALUES
  (:url, :title, :type, :description, :body, :last_visit)`;

const SQL_SELECT_MATCH = `SELECT url, title, type, description, snippet(fts_pages) AS snippet, last_visit
  FROM fts_pages WHERE fts_pages MATCH :keywords ORDER BY last_visit DESC`;

const SQL_DROPS = ["DROP TABLE IF EXISTS fts_pages"];

function FullTextSearchStore(path) {
  this._path = path || OS.Path.join(OS.Constants.Path.localProfileDir, FTSSTORE_NAME);
  console.log("===== PATH: ", this._path);
  this._conn = null;
  this._dataExpiryJob = null;
}

FullTextSearchStore.prototype = {
  /**
   * Creates the table schema for the metadata database. This function must be called
   * after a database connection has been established
   */
  _asyncCreateTableSchema: Task.async(function*() {
    try {
      yield this._conn.executeTransaction(function*() {
        for (let ddl of SQL_DDLS) {
          yield this._conn.execute(ddl);
        }
        for (let migration of SQL_MIGRATIONS) {
          yield this._conn.execute(migration);
        }
      }.bind(this));
    } catch (e) {
      Cu.reportError("FullTextSearchStore failed to create tables.");
      throw e;
    }
  }),

  get transactionInProgress() {
    return this._conn.transactionInProgress;
  },

  /**
   * Creates a connection to the metadata database. It sets the journal mode
   * to WAL, enables the foreign key support, and also creates the tables and
   * indices if necessary
   *
   * Returns a promise that is resolved upon success, or rejected if an exception occurs
   */
  asyncConnect: Task.async(function*() {
    if (this._conn) {
      return;
    }

    try {
      this._conn = yield Sqlite.openConnection({path: this._path});
      yield this._conn.execute("PRAGMA journal_mode = WAL;");
      yield this._conn.execute("PRAGMA foreign_keys = ON;");
      yield this._asyncCreateTableSchema();
    } catch (e) {
      Cu.reportError("FullTextSearchStore failed to create connection: " + e.message);
      throw e;
    }
  }),

  asyncClose: Task.async(function*() {
    if (this._conn) {
      yield this._conn.close();
      this._conn = null;
    }
  }),

  _asyncGetLastInsertRowID: Task.async(function*() {
    let result = yield this._conn.execute(SQL_LAST_INSERT_ROWID);
    return result[0].getResultByName("lastInsertRowID");
  }),

  /**
   * Inserts the raw page info into the database. It consists of two tables,
   * i.e. page_metadata for the regular meta information of the page, and
   * page_images for the favicon and preview images.
   *
   * pageObjects, an array of metadata objects that currently generated by embed.ly
   * Returns a promise that is resolved upon success, or rejected if an exception occurs
   */
  asyncInsert: Task.async(function*(pageObjects) {
    for (let metaObject of pageObjects) {
      yield this._conn.executeTransaction(function*() {
        try {
          let metadataBindings = metaObject;
          yield this._conn.executeCached(SQL_INSERT_FTS_PAGES, metadataBindings);
        } catch (e) {
          Cu.reportError("FullTextSearchStore failed to insert metadata: " + e.message);
          throw e;
        }
      }.bind(this));
    }
  }),

  /**
   * Drops all the tables and the corresponding indices, the table schema remains
   *
   * Returns a promise that is resolved upon success, or rejected if an exception occurs
   */
  asyncDrop: Task.async(function*() {
    try {
      yield this._conn.executeTransaction(function*() {
        for (let drop of SQL_DROPS) {
          yield this._conn.execute(drop);
        }
      }.bind(this));
      yield this._asyncCreateTableSchema();
    } catch (e) {
      Cu.reportError("FullTextSearchStore failed to drop: " + e.message);
      throw e;
    }
  }),

  /**
   * Executes arbitrary query against metadata database. For bulk insert, use
   * asyncInsert function instead
   *
   * @param {String} aSql
   *        SQL query to execute
   * @param {Object} [optional] aOptions
   *        aOptions.columns - an array of column names. if supplied the return
   *        items will consists of objects keyed on column names. Otherwise
   *        array of raw values is returned in the select order
   *        aOptions.param - an object of SQL binding parameters
   *        aOptions.callback - a callback to handle query raws
   *
   * Returns a promise with the array of retrieved items
   */
  asyncExecuteQuery: Task.async(function*(aSql, aOptions = {}) {
    let {columns, params, callback} = aOptions;
    let items = [];
    let queryError = null;

    yield this._conn.executeCached(aSql, params, aRow => {
      try {
        // check if caller wants to handle query raws
        if (callback) {
          callback(aRow);
        }
        // otherwise fill in the item and add items array
        else {
          let item = null;
          // if columns array is given construct an object
          if (columns && Array.isArray(columns)) {
            item = {};
            columns.forEach(column => {
              item[column] = aRow.getResultByName(column);
            });
          } else {
            // if no columns - make an array of raw values
            item = [];
            for (let i = 0; i < aRow.numEntries; i++) {
              item.push(aRow.getResultByIndex(i));
            }
          }
          items.push(item);
        }
      } catch (e) {
        queryError = e;
        throw StopIteration;
      }
    });
    if (queryError) {
      throw new Error(queryError);
    }
    return items;
  }),

  asyncSearchBookmarks(keywords) {
    return new Promise(function(resolve, reject) {
      bookmarks.search(
        {query: keywords},
        {
          sort: "date",
          descending: true
        }
      ).on("end", results => {
        resolve(results);
      }).on("error", error => {
        resolve([]);
      });
    });
  },

  asyncSearchHistory(keywords, limit) {
    return new Promise(function(resolve, reject) {
      history.search(
        {query: keywords},
        {
          count: limit,  // limit 50 for now
          sort: "date",
          descending: true
        }
      ).on("end", results => {
        resolve(results);
      }).on("error", error => {
        resolve([]);
      });
    });
  },

  asyncSearchTabs(keywords) {
    return new Promise(function(resolve, reject) {
      const searchTerm = keywords.toLowerCase();
      let matchedTabs = [];
      for (let tab of tabs) {
        if (tab.title.toLowerCase().indexOf(searchTerm) > -1 ||
          tab.url.toLowerCase().indexOf(searchTerm) > -1) {
          matchedTabs.push({
            title: tab.title,
            url: tab.url,
            id: tab.id
          });
        }
      }
      resolve(matchedTabs);
    });
  },

  asyncSearchPagesPrefix: Task.async(function*(keywords) {
    let results = yield this.asyncExecuteQuery(
      SQL_SELECT_MATCH,
      {
        params: {keywords: `${keywords}*`}
      });
    return results;
  }),

  asyncSearchPagesExact: Task.async(function*(keywords) {
    let results = yield this.asyncExecuteQuery(
      SQL_SELECT_MATCH,
      {
        params: {keywords: `${keywords}`},
        columns: ["title", "url", "type", "last_visit", "snippet"]
      });
    return results;
  }),

  asyncSearchGeneric: Task.async(function*(options) {
    let queryTasks = [];
    let {keywords, sources} = options;

    for (let source of sources) {
      switch (source) {
        case "bookmarks":
          queryTasks.push(this.asyncSearchBookmarks(keywords));
          break;
        case "history":
          queryTasks.push(this.asyncSearchHistory(keywords, 50));
          break;
        case "pages":
          queryTasks.push(this.asyncSearchPagesExact(keywords));
          break;
        case "tabs":
          queryTasks.push(this.asyncSearchTabs(keywords));
          break;
        default:
          throw new Error("Invalid query source");
      }
    }

   let results = yield Promise.all(queryTasks);
   let obj = {};
   sources.forEach((source, i, sources) => {
     obj[source] = results[i];
   });

   return obj;
  })
};

exports.FullTextSearchStore = FullTextSearchStore;
